```{=html}
<style>
.map-controls {
  display: flex !important;
  flex-direction: row !important;
  justify-content: center !important;
  gap: 8px !important;
  margin-top: 8px !important;
}
.map-controls button {
  display: inline-flex !important;
  align-items: center;
  justify-content: center;
  padding: 6px 10px;
  white-space: nowrap;
  cursor: pointer;
}
</style>

<!-- MAP: only canvas + zoom buttons go inside this container -->
<div class="map-container" style="position:relative; width:100%; height:600px; border:1px solid #ddd; border-radius:6px; overflow:hidden; background-image:url('../../img/lulcc.png'); background-size:cover;">

  <!-- Canvas -->
  <canvas id="mapCanvas" style="width:100%; height:100%; display:block;"></canvas>

  <!-- Zoom buttons on top-right -->
  <div class="zoom" style="position:absolute; top:10px; right:10px; display:flex; flex-direction:column; gap:6px; z-index:30;">
    <button class="out" data-zoomstep="0.8">-</button>
    <button class="in" data-zoomstep="1.2">+</button>
  </div>

  <!-- Tooltip -->
  <div id="mapTooltip" style="position:absolute; display:none; background:white; border:1px solid black; padding:3px 6px; font-size:0.9em; border-radius:3px;"></div>

</div> <!-- ðŸ‘ˆ END of .map-container -->

<script>
// Global map control object to interface with Quarto tabsets
window.mapController = {};

document.addEventListener("DOMContentLoaded", function() {
  const container = document.querySelector('.map-container');
  const canvas = document.getElementById('mapCanvas');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('mapTooltip');

  // Image sources for different layers
  const imageSources = {
    '2020': '../../img/lulc.png',
    '2060': '../../img/lulc_2060.png', // adjust path as needed
    'change': '../../img/lulc_change.png' // adjust path as needed
  };

  // Current state
  let currentLayer = '2020';
  let protectedAreasVisible = true;

  // Image cache
  const imageCache = {};

  // Load all images
  Object.keys(imageSources).forEach(key => {
    const img = new Image();
    img.src = imageSources[key];
    imageCache[key] = img;
  });

  // Get current active image
  function getCurrentImage() {
    return imageCache[currentLayer] || imageCache['2020'];
  }

  // draw image to current canvas size
  function redraw() {
    const img = getCurrentImage();
    if (!img.complete) return;
    // clear & draw
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // Add protected areas overlay if enabled
    if (protectedAreasVisible) {
      // Add your protected areas overlay logic here
      // This could be another image or vector overlay
    }
  }

  // size canvas to container client size
  function resizeCanvas() {
    const w = Math.max(1, container.clientWidth);
    const h = Math.max(1, container.clientHeight);
    // set internal resolution to match CSS pixels (simple approach)
    canvas.width = w;
    canvas.height = h;
    // ensure CSS visual size is correct
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    redraw();
  }

  // initial sizing after first image loads
  imageCache['2020'].onload = function() {
    resizeCanvas();
    redraw();
  };

  // also call resize on window change
  window.addEventListener('resize', resizeCanvas);

  // Basic pan / drag logic
  let isDragging=false, startX=0, startY=0, translateX=0, translateY=0, origX=0, origY=0;
  let scale = 1;

  canvas.addEventListener('mousedown', e => {
    isDragging = true; startX = e.clientX; startY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });
  document.addEventListener('mouseup', () => {
    isDragging = false; origX = translateX; origY = translateY;
    canvas.style.cursor = 'default';
  });
  document.addEventListener('mousemove', e => {
    if(!isDragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    translateX = origX + dx;
    translateY = origY + dy;
    canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  });

  // Zoom buttons (on map)
  document.querySelector('.zoom .in').addEventListener('click', () => {
    scale *= 1.2;
    canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  });
  document.querySelector('.zoom .out').addEventListener('click', () => {
    scale *= 0.8;
    canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  });

  // Tooltip (reads pixel color)
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    // convert mouse to canvas pixel coords (account for CSS scaling via canvas.width/height)
    const x = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width) / (scale || 1));
    const y = Math.floor((e.clientY - rect.top ) * (canvas.height / rect.height) / (scale || 1));
    if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) { tooltip.style.display = 'none'; return; }
    try {
      const pixel = ctx.getImageData(x,y,1,1).data;
      const hex = '#' + pixel[0].toString(16).padStart(2,'0') +
                        pixel[1].toString(16).padStart(2,'0') +
                        pixel[2].toString(16).padStart(2,'0');
      // example mapping (adjust to your colors)
      const landUse = {
        "#ff0000": "Urban Area",
        "#00ff00": "Forest",
        "#0000ff": "Water"
      };
      const name = landUse[hex.toLowerCase()];
      if(name){
        tooltip.style.display = 'block';
        // keep tooltip inside viewport
        tooltip.style.left = Math.min(window.innerWidth - 120, e.clientX + 8) + 'px';
        tooltip.style.top  = Math.max(8, e.clientY - 30) + 'px';
        tooltip.textContent = name;
      } else {
        tooltip.style.display = 'none';
      }
    } catch(err){
      // security issues with cross-origin images: if so, disable pixel read
      tooltip.style.display = 'none';
    }
  });
  canvas.addEventListener('mouseout', ()=> tooltip.style.display='none');

  // Expose functions for Quarto tabset integration
  window.mapController = {
    switchTo2020: function() {
      currentLayer = '2020';
      redraw();
    },
    switchTo2060: function() {
      currentLayer = '2060';
      redraw();
    },
    switchToChange: function() {
      currentLayer = 'change';
      redraw();
    },
    toggleProtectedAreas: function() {
      protectedAreasVisible = !protectedAreasVisible;
      redraw();
      return protectedAreasVisible;
    },
    getCurrentLayer: function() {
      return currentLayer;
    },
    isProtectedAreasVisible: function() {
      return protectedAreasVisible;
    }
  };

  // ensure correct initial sizing if image already cached
  if (imageCache['2020'].complete) {
    resizeCanvas();
    redraw();
  }
});
</script>
```
