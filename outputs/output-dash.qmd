---
title: "NASCENT Scenario Explorer"
format: 
  dashboard:
    orientation: columns
    expandable: false
#title-block-banner: "#f6f8fa"
popover-glossary:
  path: glossary.yml
execute:
  freeze: false
  cache: false
  echo: false
bibliography: references.bib
---

```{css}
.card {
  border: none !important;
  box-shadow: none;  /* optional, also removes subtle shadow */
}

/* --- Outer card-tabsets (dashboard top-level tabs) --- */
.card-header.bslib-navs-card-title {
  background-color: #29898f !important;   /* teal background */
  border-bottom: 3px solid #1f5f66;
  padding: 0.25rem 0.5rem;
  border-radius: 0.5rem 0.5rem 0 0;
}

/* Outer card-tab labels */
.card-header.bslib-navs-card-title .nav-link {
  color: white !important;
  font-weight: 600;
  border: none !important;
  margin-right: 0.25rem;
  border-radius: 0.5rem 0.5rem 0 0;
}

/* Outer card active tab */
.card-header.bslib-navs-card-title .nav-link.active {
  background-color: #1f5f66 !important;
  color: #fff !important;
}

/* Outer card hover */
.card-header.bslib-navs-card-title .nav-link:hover {
  background-color: #3a7a89 !important;
  color: #fff !important;
}

/* --- Inner panel-tabsets --- */
.panel-tabset > .nav-tabs {
  background-color: #f5f5f5 !important;  /* light gray */
  border-bottom: 2px solid #ccc;
  padding: 0.25rem 0.5rem;
  border-radius: 0.5rem 0.5rem 0 0;
}

/* Inner panel tab labels */
.panel-tabset > .nav-tabs .nav-link {
  color: #555 !important;
  font-weight: 500;
  border: none !important;
  margin-right: 0.25rem;
  border-radius: 0.5rem 0.5rem 0 0;
  transition: background-color 0.2s ease, color 0.2s ease;
}

/* Inner panel active tab */
.panel-tabset > .nav-tabs .nav-link.active {
  background-color: #29898f !important;  /* teal */
  color: white !important;
  font-weight: 600;
  border: none !important;
}

/* Inner panel hover */
.panel-tabset > .nav-tabs .nav-link:hover {
  background-color: #ddd !important;
  color: black !important;
}

```

```{=html}
<style>
.map-container {
  position: relative;
  width: 100%;
  height: 600px;
  border: 1px solid #ddd;
  border-radius: 6px;
  overflow: hidden;
}

.zoom {
  position: absolute;
  top: 10px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  z-index: 30;
}

.zoom button {
  display: inline-flex !important;
  align-items: center;
  justify-content: center;
  padding: 8px 12px;
  cursor: pointer;
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid #666;
  border-radius: 4px;
  font-size: 16px;
  font-weight: bold;
  color: #333;
  min-width: 35px;
  min-height: 35px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.zoom button:hover {
  background: rgba(255, 255, 255, 1);
  border-color: #333;
}

.zoom button:active {
  background: rgba(240, 240, 240, 1);
}

#mapTooltip {
  position: absolute;
  display: none;
  background: white;
  border: 1px solid black;
  padding: 3px 6px;
  font-size: 0.9em;
  border-radius: 3px;
  pointer-events: none;
  z-index: 40;
}
</style>

<script>
function createInteractiveMap(containerId, imagePath, language = 'en') {
  // Swiss land use color mapping
  const colorMapping = {
    "#a8aba5": language === 'de' ? "Siedlungsfl채chen" : "Urban",
    "#d1d3cf": language === 'de' ? "Statisch" : "Static",
    "#97d1d5": language === 'de' ? "Offener Wald" : "Open forest",
    "#29898f": language === 'de' ? "Geschlossener Wald" : "Closed forest",
    "#bb8a75": language === 'de' ? "Geb체schfl채chen" : "Overgrown",
    "#f59f78": language === 'de' ? "Intensive Landwirtschaft" : "Intensive agriculture",
    "#6ca147": language === 'de' ? "Alpwirtschaftsfl채chen" : "Alpine pastures",
    "#c4e0a1": language === 'de' ? "Naturwiesen und Heimweiden" : "Grassland",
    "#f8eb52": language === 'de' ? "Dauerkulturen" : "Permanent crops",
    "#d5f1ff": language === 'de' ? "Gletscher" : "Glacier"
  };
  const container = document.getElementById(containerId);
  const canvas = container.querySelector('canvas');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('mapTooltip') || createTooltip();
  
  function createTooltip() {
    const tip = document.createElement('div');
    tip.id = 'mapTooltip';
    tip.className = 'map-tooltip';
    document.body.appendChild(tip);
    return tip;
  }
  
  const mapImage = new Image();
  mapImage.src = imagePath;
  
  let isDragging = false, startX = 0, startY = 0, translateX = 0, translateY = 0, origX = 0, origY = 0, scale = 1;
  
  function redraw() {
    if (!mapImage.complete) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);
  }
  
  function resizeCanvas() {
    const w = Math.max(1, container.clientWidth);
    const h = Math.max(1, container.clientHeight);
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    redraw();
  }
  
  mapImage.onload = () => { 
    resizeCanvas(); 
    redraw(); 
    console.log('Map loaded for:', containerId);
  };
  
  window.addEventListener('resize', resizeCanvas);
  
  // Pan/drag functionality
  canvas.addEventListener('mousedown', e => {
    isDragging = true; 
    startX = e.clientX; 
    startY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });
  
  document.addEventListener('mouseup', () => {
    if (!isDragging) return;
    isDragging = false; 
    origX = translateX; 
    origY = translateY;
    canvas.style.cursor = 'default';
  });
  
  document.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    translateX = origX + dx; 
    translateY = origY + dy;
    canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  });
  
  // Zoom functionality
  const zoomInBtn = container.querySelector('.zoom .in');
  const zoomOutBtn = container.querySelector('.zoom .out');
  
  if (zoomInBtn) {
    zoomInBtn.addEventListener('click', (e) => {
      e.preventDefault();
      scale *= 1.2;
      canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
      console.log('Zoom in, scale:', scale);
    });
  } else {
    console.error('Zoom in button not found in container:', containerId);
  }
  
  if (zoomOutBtn) {
    zoomOutBtn.addEventListener('click', (e) => {
      e.preventDefault();
      scale *= 0.8;
      canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
      console.log('Zoom out, scale:', scale);
    });
  } else {
    console.error('Zoom out button not found in container:', containerId);
  }
  
  // Tooltip functionality
  canvas.addEventListener('mousemove', e => {
    console.log('Mouse move detected on canvas');
    
    // Always show a test tooltip first
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX + 8) + 'px';
    tooltip.style.top = (e.clientY - 30) + 'px';
    tooltip.textContent = 'Mouse detected';
    tooltip.style.background = 'red';
    tooltip.style.color = 'white';
    
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width) / scale);
    const y = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height) / scale);
    
    console.log('Mouse position:', e.clientX, e.clientY, 'Canvas coords:', x, y);
    console.log('Canvas dimensions:', canvas.width, canvas.height);
    console.log('Scale:', scale);
    
    if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
      console.log('Mouse outside canvas bounds');
      tooltip.textContent = 'Outside bounds';
      return;
    }
    
    try {
      console.log('Attempting to read pixel data...');
      const pixel = ctx.getImageData(x, y, 1, 1).data;
      console.log('Pixel data successfully read:', pixel);
      
      const hex = '#' + pixel[0].toString(16).padStart(2, '0') +
                        pixel[1].toString(16).padStart(2, '0') +
                        pixel[2].toString(16).padStart(2, '0');
      
      console.log('Detected color:', hex, 'RGB:', pixel[0], pixel[1], pixel[2]);
      
      tooltip.textContent = `Color: ${hex} RGB: ${pixel[0]},${pixel[1]},${pixel[2]}`;
      tooltip.style.background = 'yellow';
      tooltip.style.color = 'black';
      
    } catch (err) {
      console.error('Error reading pixel data:', err);
      tooltip.textContent = 'Pixel read error: ' + err.message;
      tooltip.style.background = 'orange';
      tooltip.style.color = 'black';
    }
  });
  
  canvas.addEventListener('mouseout', () => {
    tooltip.style.display = 'none';
  });
  
  if (mapImage.complete) { resizeCanvas(); redraw(); }
}
</script>
```

# Land Use Change

## Scenarios {.tabset}

### BAU

:::: {.panel-tabset}

#### 2020
::: {layout="[ [1,1] ]" column-widths="1,1"}

:::{.card expandable="true"}
<!-- Map -->
```{=html}
<div class="map-container" id="map2020">
  <canvas style="width:100%; height:100%; display:block;"></canvas>
  <div class="zoom">
    <button class="out">-</button>
    <button class="in">+</button>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  createInteractiveMap('map2020', '../../img/lulc.png', 'en'); // 'en' for English, 'de' for German
});
</script>
```
:::

:::{.card expandable="true"}
<!-- Create a bar chart with plotly -->
```{r}
library(plotly)
library(jsonlite)
library(dplyr)

# load json file of perc area
lulc_2020 <- fromJSON("outputs/data/lulc-2020-perc_area.json", flatten = TRUE)

# convert to DF
lulc_2020_df <- data.frame(
  class = unlist(lulc_2020),
  perc_area = as.numeric(names(lulc_2020))
)
row.names(lulc_2020_df) <- NULL

# colour palette
LULC_pal <- list("Urban/amenities" = '#a8aba5', #Urban
            "Static" = "#d1d3cf", #static
            "Open Forest" = "#97d1d5", #Open forest
            "Closed forest" = "#29898f", #closed forest
            "Overgrown/shrubland" = "#bb8a75", #Shrubland
            "Intensive agriculture" =  "#f59f78", #Intensive agriculture
            "Alpine pastures" = "#6ca147", #Alpine pastures
            "Grassland or meadows" = "#c4e0a1", #Grassland
            "Permanent crops" = "#DDCC66", #Permanet crops
            "Glacier" = "#d5f1ff",
            "River" = "#93d0ee",
            "Lake" = "#93d0ee")

#add the colours and clean names to the df in the current order
lulc_2020_df$color <- unlist(LULC_pal)
lulc_2020_df$clean_class <- names(LULC_pal)

# create the plotly bar chart with no labels on the bars and no x axis title or main title
p <- plot_ly(lulc_2020_df, 
             x = ~clean_class, 
             y = ~perc_area, 
             type = 'bar',
             marker = list(color = ~color),
             text = ~paste0(round(perc_area, 2), '%'),
             textposition = 'none') %>%
  layout(
    title = list(text = "% Area of Land Use Classes in 2020"),  
    xaxis = list(title = ""), # remove x-axis title
    yaxis = list(title = "Percentage Area (%)", range = c(0, 100)),
    showlegend = FALSE,
    margin = list(b = 150)      # keep space for long x labels
  )%>%
  config(displayModeBar = FALSE) 
p

```
:::

:::

#### 2060

#### Change

::::

### Nature for Society

#### Map

#### Bar

### Nature for Nature

#### Map

#### Bar

### Nature as Culture

#### Map

#### Bar

# Ecosystem Services & Biodiversity

# Economic impacts
